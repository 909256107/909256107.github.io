<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>docker部署</title>
      <link href="/2020/09/22/docker-bu-shu/"/>
      <url>/2020/09/22/docker-bu-shu/</url>
      
        <content type="html"><![CDATA[<ul><li><h1 id="Docker通过jar包部署并运行"><a href="#Docker通过jar包部署并运行" class="headerlink" title="Docker通过jar包部署并运行"></a>Docker通过jar包部署并运行</h1><ol><li><p>上传jar到服务器的指定目录</p></li><li><p>在该目录下创建Dockerfile 文件</p><pre><code> vim Dockerfile</code></pre><p> 注意：</p><pre><code> X86和ARM 的jdk版本不一样 X86的Dockerfile文件如下： FROM java:8 MAINTAINER bingo ADD demo-0.0.1-SNAPSHOT.jar demo.jar EXPOSE 8080 ENTRYPOINT [&quot;java&quot;,&quot;-jar&quot;,&quot;demo.jar&quot;]</code></pre><p> ARM的Dockerfile文件如下：</p><pre><code> FROM arm64v8/openjdk:8 MAINTAINER duan ADD springBootDocker.jar demo.jar EXPOSE 8888    ENTRYPOINT [&quot;java&quot;,&quot;-jar&quot;,&quot;demo.jar&quot;]</code></pre><p> 说明：</p><pre><code> from java:8   拉取一个jdk为1.8的docker image maintainer  作者是duan demo-0.0.1-SNAPSHOT.jar 就是你上传的jar包，替换为jar包的名称 demo.jar  是你将该jar包重新命名为什么名称，在容器中运行 expose  该容器暴露的端口是多少，就是jar在容器中以多少端口运行 entrypoint 容器启动之后执行的命令，java -jar demo.jar  即启动jar</code></pre></li><li><p>创建好Dockerfile文件之后，执行命令 构建镜像</p></li></ol></li></ul><pre><code>        docker build -t my/demo .    注意最后的 .  表示 Dockerfile 文件在当前目录下    my/demo  构建之后镜像名称4. 镜像构建成功之后，就可以运行容器了        docker run -d --restart=always --name demo -p 8080:8080  my/demo   5. 一些常用的docker命令        docker ps :查看正在运行中的容器        docker ps - a :  查看所有的容器        docker stop/start 容器名 ：启动停止容器        docker rm 容器id:删除容器        docker images: 查看镜像        docker rmi 镜像id:删除镜像</code></pre>]]></content>
      
      
      <categories>
          
          <category> 项目部署 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 原创 </tag>
            
            <tag> docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Echart接收Ajax传递过来的json数据</title>
      <link href="/2020/09/22/echart-jie-shou-ajax-chuan-di-guo-lai-de-json-shu-ju/"/>
      <url>/2020/09/22/echart-jie-shou-ajax-chuan-di-guo-lai-de-json-shu-ju/</url>
      
        <content type="html"><![CDATA[<h2 id="效果图"><a href="#效果图" class="headerlink" title="效果图"></a>效果图</h2><p><img src="https://img-blog.csdnimg.cn/20200918194249836.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNDE3Mjc2,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><h2 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h2><p>前端代码</p><pre><code>&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot;&gt;    &lt;title&gt;图形输出&lt;/title&gt;    &lt;script src=&quot;js/jquery-1.9.1.min.js&quot;&gt;&lt;/script&gt;    &lt;script src=&quot;js/echarts.min.js&quot;&gt;&lt;/script&gt;    &lt;script src=&quot;js/echarts.helper.js&quot;&gt;&lt;/script&gt;&lt;/head&gt;&lt;body onresize=&quot;myFunction()&quot;&gt;&lt;!-- 为 ECharts 准备一个具备大小（宽高）的 DOM --&gt;&lt;div id=&quot;main&quot; style=&quot;width: 100%;height:400px;&quot;&gt;&lt;/div&gt;&lt;/body&gt;&lt;script type=&quot;text/javascript&quot;&gt;    function myFunction(){        var w = window.outerHeight;        var h =window.outerHeight;    }    var myChart = echarts.init(document.getElementById(&#39;main&#39;));    // 显示标题，图例和空的坐标轴    myChart.setOption({        title: {            text: &#39;贪夜蛾自动检测&#39;        },        tooltip: {            trigger: &#39;axis&#39;, //触发类型；轴触发，axis则鼠标hover到一条柱状图显示全部数据，item则鼠标hover到折线点显示相应数据，            axisPointer: {  //坐标轴指示器，坐标轴触发有效，                type: &#39;line&#39;, //默认为line，line直线，cross十字准星，shadow阴影                crossStyle: {                    color: &#39;#fff&#39;                }            }        },        legend: {            data:[&#39;红外计数&#39;,&#39;PM2.5&#39;,&#39;温度&#39;,&#39;湿度&#39;]        },        xAxis: {            boundaryGap: false,            data: []        },        grid: {            left: &#39;3%&#39;,            right: &#39;4%&#39;,            bottom: &#39;3%&#39;,            containLabel: true        },        toolbox: {            feature: {                saveAsImage: {}            }        },        yAxis: {},        series: [{            name: &#39;红外计数&#39;,            type: &#39;line&#39;,            data: []        },{            name: &#39;PM2.5&#39;,            type: &#39;line&#39;,            data: []        },{            name: &#39;温度&#39;,            type: &#39;line&#39;,            data: []        },{            name: &#39;湿度&#39;,            type: &#39;line&#39;,            data: []        }]    });    myChart.showLoading();    //数据加载完之前先显示一段简单的loading动画    var names=[];    //类别数组（实际用来盛放X轴坐标值）    var nums=[];    //销量数组（实际用来盛放Y坐标值）    var nums1=[];    var nums2=[];    var nums3=[];    $.ajax({        type : &quot;post&quot;,        async : true,            //异步请求（同步请求将会锁住浏览器，用户其他操作必须等待请求完成才可以执行）        url : &quot;/datass/selectAll&quot;,    //请求发送到TestServlet处        data : {},        dataType : &quot;json&quot;,        //返回数据形式为json        success : function(result) {            //请求成功时执行该函数内容，result即为服务器返回的json对象            if (result) {                for(var i=0;i&lt;result.length;i++){                    names.push(result[i].nowtime);    //挨个取出类别并填入类别数组                }                for(var i=0;i&lt;result.length;i++){                    nums.push(result[i].hongwai);    //挨个取出销量并填入销量数组                }                for(var i=0;i&lt;result.length;i++){                    nums1.push(result[i].pm);                }                for(var i=0;i&lt;result.length;i++){                    nums2.push(result[i].wendu);                    nums3.push(result[i].shidu);                }                myChart.hideLoading();    //隐藏加载动画                myChart.setOption({        //加载数据图表                    xAxis: {                        data: names                    },                    series: [{                        // 根据名字对应到相应的系列                        name: &#39;红外计数&#39;,                        data: nums                    },{                        name: &#39;PM2.5&#39;,                        data: nums1                    },{                        name: &#39;温度&#39;,                        data: nums2                    },{                        name: &#39;湿度&#39;,                        data: nums3                    }]                });                myChart.setOption(option);                setTimeout(function (){                    window.onresize = function (){                        myChart.resize();                    }                },200)            }        },        error : function(errorMsg) {            //请求失败时执行该函数            alert(&quot;图表请求数据失败!&quot;);            myChart.hideLoading();        }    })    // window.onresize = myChart.resize();    // $(&quot;#main&quot;).resize(myChart.resize);    // myChart.setOption(option);    myChart.setOption(option);    setTimeout(function (){        window.onresize = function (){            myChart.resize();        }    },200)&lt;/script&gt;&lt;/html&gt;</code></pre><p>后台传送json数据</p><pre><code> @RequestMapping(&quot;/selectAll&quot;)    @ApiOperation(&quot;查询所有&quot;)    public List&lt;Datas&gt; selectAll(Map map){        return datasService.selectAll(map);    }</code></pre><p>前端接收的json数据</p><pre><code>[{&quot;id&quot;:1,&quot;nowtime&quot;:&quot;2020-09-16 21:05:15&quot;,&quot;hongwai&quot;:12,&quot;fengxiang&quot;:&quot;南偏北风&quot;,&quot;fengsu&quot;:&quot;20.3&quot;,&quot;wendu&quot;:36.5,&quot;shidu&quot;:45.1,&quot;pm&quot;:52.3,&quot;tWendu10&quot;:34.2,&quot;tShidu10&quot;:32.1,&quot;tWendu20&quot;:30.5,&quot;tShidu20&quot;:24.1,&quot;tWendu30&quot;:20.4,&quot;tShidu30&quot;:40.5},{&quot;id&quot;:2,&quot;nowtime&quot;:&quot;2020-09-02 17:49:11&quot;,&quot;hongwai&quot;:23,&quot;fengxiang&quot;:&quot;北风&quot;,&quot;fengsu&quot;:&quot;21.4&quot;,&quot;wendu&quot;:45.6,&quot;shidu&quot;:48.4,&quot;pm&quot;:54.7,&quot;tWendu10&quot;:45.8,&quot;tShidu10&quot;:10.2,&quot;tWendu20&quot;:23.5,&quot;tShidu20&quot;:24.5,&quot;tWendu30&quot;:27.1,&quot;tShidu30&quot;:16.4}]</code></pre>]]></content>
      
      
      <categories>
          
          <category> json </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 原创 </tag>
            
            <tag> web前端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Mybatis逆向工程</title>
      <link href="/2020/09/22/mybatis-ni-xiang-gong-cheng/"/>
      <url>/2020/09/22/mybatis-ni-xiang-gong-cheng/</url>
      
        <content type="html"><![CDATA[<ul><li><h2 id="逆向工程所依赖的jar包"><a href="#逆向工程所依赖的jar包" class="headerlink" title="逆向工程所依赖的jar包"></a>逆向工程所依赖的jar包</h2></li></ul><pre><code> &lt;dependencies&gt;       &lt;dependency&gt;           &lt;groupId&gt;org.mybatis&lt;/groupId&gt;           &lt;artifactId&gt;mybatis&lt;/artifactId&gt;           &lt;version&gt;3.4.5&lt;/version&gt;       &lt;/dependency&gt;       &lt;dependency&gt;           &lt;groupId&gt;org.mybatis.generator&lt;/groupId&gt;           &lt;artifactId&gt;mybatis-generator-core&lt;/artifactId&gt;           &lt;version&gt;1.3.5&lt;/version&gt;       &lt;/dependency&gt;       &lt;dependency&gt;           &lt;groupId&gt;mysql&lt;/groupId&gt;           &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;           &lt;version&gt;5.1.6&lt;/version&gt;       &lt;/dependency&gt;       &lt;dependency&gt;           &lt;groupId&gt;org.springframework&lt;/groupId&gt;           &lt;artifactId&gt;spring-jdbc&lt;/artifactId&gt;           &lt;version&gt;5.0.2.RELEASE&lt;/version&gt;       &lt;/dependency&gt;   &lt;/dependencies&gt;</code></pre><ul><li><h2 id="generator-xml配置文件"><a href="#generator-xml配置文件" class="headerlink" title="generator.xml配置文件"></a>generator.xml配置文件</h2></li></ul><pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;!DOCTYPE generatorConfiguration        PUBLIC &quot;-//mybatis.org//DTD MyBatis Generator Configuration 1.0//EN&quot;        &quot;http://mybatis.org/dtd/mybatis-generator-config_1_0.dtd&quot;&gt;&lt;generatorConfiguration&gt;&lt;!--生成的jar包都是3点多--&gt;    &lt;context id=&quot;testTables&quot; targetRuntime=&quot;MyBatis3&quot;&gt;        &lt;commentGenerator&gt;&lt;!--            suppressAllComments属性值：--&gt;&lt;!--            ture:自动生成实体类，SQL映射文件时没有注释--&gt;&lt;!--            fauls:自动生成实体类，SQL映射文件有注释--&gt;            &lt;property name=&quot;suppressAllComments&quot; value=&quot;true&quot;/&gt;        &lt;/commentGenerator&gt;        &lt;!-- 数据库连接信息 驱动类 连接地址 用户名 密码 --&gt;        &lt;jdbcConnection driverClass=&quot;com.mysql.jdbc.Driver&quot;                        connectionURL=&quot;jdbc:mysql://localhost:3306/spring&quot;                        userId=&quot;root&quot;                        password=&quot;123456&quot;&gt;        &lt;/jdbcConnection&gt;&lt;!--    forceBigDecimals属性值：        ture:把数据表中的DECTMAL和NUMERIC类型解析为java.math.BigDecimal类型        false:解析为Integer类型        --&gt;        &lt;javaTypeResolver &gt;            &lt;property name=&quot;forceBigDecimals&quot; value=&quot;false&quot; /&gt;        &lt;/javaTypeResolver&gt;        &lt;!--targetProject属性值:实体类的生成位置        targetPackage属性值:实体类所在包的路径 --&gt;        &lt;!-- 生成po类的位置 --&gt;        &lt;javaModelGenerator targetPackage=&quot;cn.itcast.ssm.po&quot; targetProject=&quot;.\src\main\java&quot;&gt;&lt;!--            trimStrings属性值:--&gt;&lt;!--            true:对数据库的查询结果进行trim（去空格）操作--&gt;&lt;!--            false:不进行trim操作--&gt;            &lt;property name=&quot;enableSubPackages&quot; value=&quot;true&quot; /&gt;            &lt;property name=&quot;trimStrings&quot; value=&quot;true&quot; /&gt;        &lt;/javaModelGenerator&gt;        &lt;!--        targetProject属性值:SQL映射文件的生成位置        targetPackage属性值:SQL映射文件所在包的路径        --&gt;        &lt;!-- mapper映射文件的生成位置 --&gt;        &lt;sqlMapGenerator targetPackage=&quot;cn.itcast.ssm.mapper&quot;  targetProject=&quot;.\src\main\java&quot;&gt;            &lt;property name=&quot;enableSubPackages&quot; value=&quot;true&quot; /&gt;        &lt;/sqlMapGenerator&gt;        &lt;!-- mapper接口生成的位置 --&gt;        &lt;javaClientGenerator type=&quot;XMLMAPPER&quot; targetPackage=&quot;cn.itcast.ssm.mapper&quot;  targetProject=&quot;.\src\main\java&quot;&gt;            &lt;property name=&quot;enableSubPackages&quot; value=&quot;true&quot; /&gt;        &lt;/javaClientGenerator&gt;        &lt;!-- 指定数据库表 --&gt;        &lt;table tableName=&quot;account&quot;&gt;&lt;/table&gt;        &lt;table tableName=&quot;user&quot;&gt;&lt;/table&gt;    &lt;/context&gt;&lt;/generatorConfiguration&gt;</code></pre><p>运行测试方法类</p><pre><code>import org.mybatis.generator.api.MyBatisGenerator;import org.mybatis.generator.config.Configuration;import org.mybatis.generator.config.xml.ConfigurationParser;import org.mybatis.generator.exception.InvalidConfigurationException;import org.mybatis.generator.exception.XMLParserException;import org.mybatis.generator.internal.DefaultShellCallback;import java.io.File;import java.io.IOException;import java.sql.SQLException;import java.util.ArrayList;import java.util.List;public class Test {    public static void main(String[] args) throws IOException, XMLParserException, SQLException, InterruptedException, InvalidConfigurationException {        File file = new File(&quot;src/main/resources/generator.xml&quot;);//配置文件        List&lt;String&gt; warnings = new ArrayList();        ConfigurationParser cp = new ConfigurationParser(warnings);        Configuration config = cp.parseConfiguration(file);        DefaultShellCallback callback = new DefaultShellCallback(true);        //逆向工程的核心类        MyBatisGenerator generator = new MyBatisGenerator(config,callback,warnings);        generator.generate(null);    }}</code></pre>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 原创 </tag>
            
            <tag> 逆向工程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SpringBoot热部署失败解决方案</title>
      <link href="/2020/07/30/springboot-re-bu-shu-shi-bai-jie-jue-fang-an/"/>
      <url>/2020/07/30/springboot-re-bu-shu-shi-bai-jie-jue-fang-an/</url>
      
        <content type="html"><![CDATA[<pre><code>&lt;!--热部署配置--&gt; &lt;dependency&gt;        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;      &lt;artifactId&gt;spring-boot-devtools&lt;/artifactId&gt;&lt;/dependency&gt;</code></pre><p><img src="https://img-blog.csdnimg.cn/20200423152859682.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNDE3Mjc2,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>]]></content>
      
      
      <categories>
          
          <category> 项目部署 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 原创 </tag>
            
            <tag> 项目部署 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Oracle数据库笔记</title>
      <link href="/2020/07/30/oracle-shu-ju-ku/"/>
      <url>/2020/07/30/oracle-shu-ju-ku/</url>
      
        <content type="html"><![CDATA[<h1 id="Oracle数据库笔记"><a href="#Oracle数据库笔记" class="headerlink" title="Oracle数据库笔记"></a><font color="red">Oracle数据库笔记</font></h1><ul><li><h3 id="创建表空间"><a href="#创建表空间" class="headerlink" title="创建表空间"></a>创建表空间</h3><pre class="line-numbers language-create"><code class="language-create">datafile 'c:\itheima.dbf'size 100mautoextend onnext 10m;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></li></ul><ul><li><h3 id="删除表空间"><a href="#删除表空间" class="headerlink" title="删除表空间"></a>删除表空间</h3><pre><code>drop tablespace itheima;</code></pre></li><li><h3 id="创建用户"><a href="#创建用户" class="headerlink" title="创建用户"></a>创建用户</h3><pre><code>create user itheimaidentified by itheimadefault tablespace itheima;                 --给用户授权                 --oracle数据库中常用角色connect            --连接角色，基本角色resource           --开发者角色dba                --超级管理员角色</code></pre></li><li><h3 id="给itheima授予dba角色"><a href="#给itheima授予dba角色" class="headerlink" title="给itheima授予dba角色"></a>给itheima授予dba角色</h3><pre><code>grant dba to itheima;</code></pre></li><li><h2 id="切换到itheima用户下"><a href="#切换到itheima用户下" class="headerlink" title="切换到itheima用户下"></a>切换到itheima用户下</h2></li><li><h3 id="创建一个person表"><a href="#创建一个person表" class="headerlink" title="创建一个person表"></a>创建一个person表</h3><pre><code>create table person(     pid number(20),     name varchar2(10));</code></pre></li><li><h3 id="查询列表"><a href="#查询列表" class="headerlink" title="查询列表"></a>查询列表</h3><pre><code>select * from person;grant dba to itheima;</code></pre></li><li><h3 id="添加一列"><a href="#添加一列" class="headerlink" title="添加一列"></a>添加一列</h3><pre><code>alter table person add(gender number(1));</code></pre></li><li><h3 id="删除一列"><a href="#删除一列" class="headerlink" title="删除一列"></a>删除一列</h3><pre><code>alter table person drop column gender;</code></pre></li><li><h3 id="修改列名称"><a href="#修改列名称" class="headerlink" title="修改列名称"></a>修改列名称</h3><pre><code>alter table person rename column gender to sex;</code></pre></li><li><h3 id="修改列类型"><a href="#修改列类型" class="headerlink" title="修改列类型"></a>修改列类型</h3><pre><code>alter table person modify gender char(1);</code></pre></li><li><h3 id="添加一条记录-CRUD都得提交事务"><a href="#添加一条记录-CRUD都得提交事务" class="headerlink" title="添加一条记录(CRUD都得提交事务)"></a>添加一条记录(CRUD都得提交事务)</h3><pre><code>insert into person (pid,name) values(5,&#39;小明&#39;);commit;</code></pre></li><li><h3 id="修改数据"><a href="#修改数据" class="headerlink" title="修改数据"></a>修改数据</h3><pre><code>update person set name = &#39;小马&#39; where pid =5;</code></pre><ul><li><h3 id="删除表中所有记录"><a href="#删除表中所有记录" class="headerlink" title="删除表中所有记录"></a>删除表中所有记录</h3><pre><code>delete from person;</code></pre></li></ul></li><li><h3 id="删除表结构"><a href="#删除表结构" class="headerlink" title="删除表结构"></a>删除表结构</h3><pre><code>drop table person;</code></pre><p>先删除表，再次创建表，效果等用于删除表中的全部记录。在数据量的大的情况下，尤其在表中带有索引的情况下，该操作的小路很高。<br>索引可以提高查询效率，但是会影响增删改查。</p><pre><code>truncate table person;</code></pre><p>序列不真的属于任何一张表，但是可以逻辑和表绑定</p></li></ul><p>序列:默认从1开始一次递增,主要给主键复制使用</p><pre><code>nextval下一个值，currval当前值dual:虚表，知识为了不全语法，没有意义create sequence s_person;select s_person.nextval from dual;insert into person(pid,name)values(s_person.nextval,&#39;小敏&#39;);commit;</code></pre><p>scott用户，密码默认是：tiger（刚安装数据库是被锁定的，得进行解锁）</p><ul><li><h2 id="初学者必学"><a href="#初学者必学" class="headerlink" title="初学者必学"></a>初学者必学</h2></li><li><h3 id="解锁"><a href="#解锁" class="headerlink" title="解锁"></a>解锁</h3>```<br>alter  user scott account unlock;</li></ul><p>–解锁密码(重置密码)<br>alter user scott identified by tiger;<br>–切换到scoot用户<br>–切换到scott用户<br>–单行函数：作用于一行，返回一个值<br>—字符函数<br>select upper(‘yes’) from dual;–YES<br>select lower(‘YES’) from dual;<br>–数值函数<br>select round(26.18,1) from dual;–四舍五入26.2<br>select round(26.18,-1) from dual;–四舍五入30<br>select mod(10,3) from dual; –求余数1<br>–日期函数<br>–查询出emp表中所有员工距离现在几天<br>select  sysdate-e.hiredate from emp e;<br>–算出明天此刻<br>select sysdate+1 from dual;<br>—转换函数<br>–日期转换字符串<br>select to_char(sysdate,’fm yyyy-mm-dd hh24:mi:ss’) from dual;<br>–字符串转换日期<br>select to_date(‘2018-6-7 16:39:50’,’fm yyyy-mm-dd hh24:mi:ss’) from dual;<br>–通用函数<br>–算出emp表中所有员工的年薪<br>–奖金里面有null<br>select e.sal*12+nvl(e.comm,0 )from emp e;<br>—条件表达式<br>给emp表中员工起中文名称<br>select e.ename,<br>       case e.ename<br>             when ‘SMTH’ then ‘曹贼’<br>                  when ‘ALLEN’then ‘大耳贼’<br>                       when ‘WARD’ then ‘诸葛小二’<br>                                           else’无名’<br>                                                  end<br>from emp e;<br>–oracle除了起别名都用单引号，<br>–oracle专用条件表达式<br>select e.ename,<br>   decode(e.ename,<br>       ‘SMTH’,  ‘曹贼’,<br>           ‘ALLEN’, ‘大耳贼’,<br>               ‘WARD’, ‘诸葛小二’,<br>                   ‘无名’) 中文名<br>from emp e;</p><pre><code>* ## 多行函数（聚合函数）：作用于多行，返回一个值</code></pre><p>select count(1) from emp;–查询总数量 count(主键这一列)<br>select sum(sal) from emp;–工资总和<br>select min(sal) from emp;–最大工资<br>select avg(sal) from emp;–平均工资<br>–分组查询<br>–查询出每个部门的平均工资<br>–分组查询中，出现在group by 后面的原始列，才能出现在select后面<br>–没有出现在group by 后面的列，想在select后面，必须要加上聚合函数。<br>–聚合函数可以吧多行记录变为一个值<br>select e.deptno,avg(e.sal)<br>from emp e<br>group by e.deptno;<br>—查询平均工资高于2000<br>select e.deptno,avg(e.sal) asal<br>from emp e<br>group by e.deptno<br>having avg(e.sal)&gt;2000;<br>–所有条件都不能使用别名来判断<br>select ename,sal s from emp where sal&gt;1500;<br>–查询出每个部门工资高于800的员工的平均工资<br>select e.deptno,avg(e.sal) asal<br>from emp e<br>where e.sal&gt;800<br>group by e.deptno;<br>–where是过滤分组签的数据，having是过滤分组后的数据。<br>–表现形式：where必须在group by 之前，having是在group by 之后。<br>–查询出每个部门工资高于800的员工的平均工资，然后在查询出平均工资高于2000的员工<br>select e.deptno,avg(e.sal) asal<br>from emp e<br>where e.sal&gt;800<br>group by e.deptno</p><pre><code></code></pre>]]></content>
      
      
      <categories>
          
          <category> Oracle数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 原创 </tag>
            
            <tag> 数据库 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ARM架构使用Docker部署的坑</title>
      <link href="/2020/07/30/arm-xi-tong-shi-yong-docker-bu-shu-de-keng/"/>
      <url>/2020/07/30/arm-xi-tong-shi-yong-docker-bu-shu-de-keng/</url>
      
        <content type="html"><![CDATA[<ul><li><h2 id="需要注意-arm的jdk"><a href="#需要注意-arm的jdk" class="headerlink" title="需要注意 arm的jdk"></a>需要注意 arm的jdk</h2></li></ul><pre><code>FROM arm64v8/openjdk:8MAINTAINER duanADD springBootDocker.jar demo.jarEXPOSE 8888   ENTRYPOINT [&quot;java&quot;,&quot;-jar&quot;,&quot;demo.jar&quot;]</code></pre><p>创建好Dockerfile文件之后，执行命令 构建镜像：</p><pre><code>  docker build -t my/demo .</code></pre><p>  注意最后的 .  表示 Dockerfile 文件在当前目录下</p><p>   my/demo  构建之后镜像名称</p><p>   镜像构建成功之后，就可以运行容器了：</p><pre><code>   docker run -d --name demo -p 8080:8080 my/demo</code></pre>]]></content>
      
      
      <categories>
          
          <category> 项目部署 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 原创 </tag>
            
            <tag> 项目部署 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySql语法知识</title>
      <link href="/2020/02/16/sort-algorithms/"/>
      <url>/2020/02/16/sort-algorithms/</url>
      
        <content type="html"><![CDATA[<h1 id="DDL"><a href="#DDL" class="headerlink" title="DDL:"></a>DDL:</h1><pre><code>一 数据库的使用：                    mysql -uroot -p123456 登录数据库                    show databases 查看所有的数据库                    create database 数据库名字    添加数据库                    create database if not exists +数据库名字 character set +所用字节 ；创建数据库如果不存在并设置字符格式                    alter database +数据库名字 character set 字符集名称；修改数据库字符                    select database();查询正在使用的数据库名称                    use +数据库名字；二 操作表            1.创建                        &lt;1&gt;.语法：                                create table 表名（                                            列名1  数据类型，                                            列名2  数据类型，                                            .......                                            列名n  数据类型                                ）；                                注意：最后一个列名不用加逗号                        &lt;2&gt;.数据库类型                                     1. int ：整数类型                                    2. double :小数类型                                    3. date : 日期 ，只包含年月日，yyyy-mm-dd                                    4. datetime :日期 ，包含年月日时分秒 yyyy-MM-dd  HH-mm-ss                                    5. timestamp : 时间错类型  包含年月日时分秒  yyyy-MM-dd HH-mm-ss(系统会自己输进去当前时间)                                    6.varchar :字符串                                        例如   name varchar(20):姓名最大20个字符            2.查询                        &lt;1&gt; show tables;查询数据库中所有的表名称                        &lt;2&gt; desc +表名;查询表结构                         &lt;3&gt;show create table 表名;查询表的字符集            3.修改                        &lt;1&gt;修改表名                                alter table 表名 rename to 新表名                        &lt;2&gt;修改字符集                                alter table stu character set 字符集的名称;                        &lt;3&gt;添加一列                                alter table 表名 add 列名 数据类型；                        &lt;4&gt;修改列名称                                &lt;1&gt; alter table 表名 change列名  新列名  设置类型;                                &lt;2&gt; alter table 表名 modify 列名       varchar(10);                    4.删除                        drop +表名   ；   删除表                        alter table 表名 drop 被删除的列名;  删除列            5.复制                        create table stu(新创建的) like student（被复制的）;</code></pre><h3 id="模糊查询"><a href="#模糊查询" class="headerlink" title="模糊查询"></a>模糊查询</h3><ol><li>所查询字段 + like ‘%段%’<br>eg:select * from user where realname like ‘%段%’</li><li>所查询字段 + like ‘%段%’ and 所查询字段 + like ‘%飞%’<br>eg: select * from user where realname like ‘%段%’ and realname like ‘%飞%’</li><li>查询出既含有“段”同时又有“飞”的所有记录<br>select * from user where realname like ‘%段%飞%’</li></ol><h2 id="排序查询"><a href="#排序查询" class="headerlink" title="排序查询"></a>排序查询</h2><p>select * from 表名<br>order by 列名 asc ; 升序</p><p>select * from 表名<br>order by 列名 desc ; 降序</p><h2 id="DML-增删改表中的数据"><a href="#DML-增删改表中的数据" class="headerlink" title="DML:增删改表中的数据"></a>DML:增删改表中的数据</h2><pre><code>    1.添加数据                insert into 表名（列名1，列名2，列名n） values(值1，值2,....值n);            注意：列名要与值一一对应                        如果表名后，不定义列名，则默认给所有列添加值                        除了数字类型，其他类型需要引号单引号和双引号都可以  日期格式：“1893-11-11”    2.删除数据：                1.delete from 表名 [where  条件]                           例如：  DELETE FROM stu WHERE id =1;                        注意：如果不添加条件  会删除表中所有记录                2.truncate table stu ;   删除表中所有记录  ----先删除表在创建一张一样的表。    3.修改数据:                1.updata 表名 set 列名1= 值1 ，列名2= 值2 ，...[where 条件]                        例如:  UPDATE stu SET age=117 WHERE id =3;                        注意 ：如果不添加条件 会修改表中所有元素</code></pre><h2 id="DQL-”查询表中的记录-select-from-表名"><a href="#DQL-”查询表中的记录-select-from-表名" class="headerlink" title="DQL:”查询表中的记录 select * from 表名;"></a>DQL:”查询表中的记录 select * from 表名;</h2><pre><code>    1.排序查询：            order by 字句                *order by 排序字段1 排序方式1 ，排序字段2 排序方式2 ....            例如：                        SELECT * FROM stu1 ORDER BY math +排序方式                         SELECT * FROM stu1 ORDER BY math DESC, english DESC;（多组排序）            排序方式    ：    ASC:升序，默认                                DESC:降序    2.聚合函数：将一列数据作为一个整体，进行纵向的计算。                    &lt;1&gt; count : 计算个数                                    (1)select count(列名) from 表名；                                    (2)select count（ifnull（列名，0）） from 表名；                                    (3)count（*）; 选择所有的列                    &lt;2&gt; max  : 计算最大值                                    (1)SELECT MAX(列名) FROM 表名;                    &lt;3&gt; min  :  计算最小值                                    (1)SELECT MIN(列名) FROM 表名;                    &lt;4&gt; sum  :  计算和                                    (1)SELECT SUM(列名) FROM 表名;                    &lt;5&gt; avg  :   计算平均值                                    (1)SELECT AVG(列名) FROM 表名;                            注意：聚合函数的计算，排除null值。                            解决：                                    1.选择不包含非空的列                                    2.    ifnull函数    3.分组查询：            &lt;1&gt;  group by 分组字段                         SELECT FROM 表名 GROUP BY 列名;                    注意：                        1.分组之后查询的字段：分组字段  聚合函数                                SELECT sex, AVG(math) FROM stu1 GROUP BY sex;                                SELECT sex, AVG(math),COUNT(id) FROM stu1 GROUP BY sex;可以多加一些聚合函数                        2where和having的区别：                                1.where在分组之前进行限定，如果不满足条件，则不参与分组。having在分组之后进行限定，如果不进行限定，则不会查询。                                2.where后不可以跟聚合函数，having可以进行聚合函数的判断。    4.分页查询：            1.语法：limit 开始的索引，每条查询的页数。                    SELECT * FROM 表名 LIMIT 索引，所查询的页数;                    SELECT * FROM stu1 LIMIT 0,3;--第一页                    SELECT * FROM stu1 LIMIT 3,3;--第二页;                开始的索引=（当前页码 - 1）*每页显示的条数        注意：每个数据库都有独特的分页方式</code></pre><h1 id="约束："><a href="#约束：" class="headerlink" title="约束："></a>约束：</h1><pre><code>    概念：对表中的数据进行限定，保证数据的正确性，有效性和完整性。    分类：        1.主键约束：primary key        2.非空约束：not null        3.唯一约束：unique        4.外键约束：foreign key    #非空约束：not null:            1.建表时添加非空约束：                    CREATE TABLE stu3(                                id INT,                                NAME VARCHAR(20) NOT NULL                    );            2.创建表完后，添加非空约束            3.删除非空约束：ALTER TABLE stu3 MODIFY NAME VARCHAR(20);    #唯一约束：unique ，值不能重复            1.添加唯一约束：                    CREATE TABLE stu3(                                        id INT,                                        NAME VARCHAR(20)  unique                            );            2.删除唯一约束：                    AlTER TABLE STU3 DROP INDEX NAME;            3.再创建表后，添加唯一约束:                    ALTER TABLE stu2 MODIFY phonenumber VARCHAR(20) UNIQUE;    #主键约束：primary key:            1.创建表示添加主键：                            CREATE TABLE stu4(                                        id INT PRIMARY KEY,                                        NAME VARCHAR(20)                            );            2.删除主键：                    ALTER TABLE stu4 DROP PRIMARY KEY;            3.创建完表后，添加主键：                    ALTER TABLE stu4 MODIFY id INT PRIMARY KEY;            4.自动增长：                    1.概念：如果谋一列是数值类型的，使用auto_increment 可以来完成值得自动增长                    2.在创建表时，添加主键约束，并且完成主键自增长                            CREATE TABLE stu4(                                    id INT PRIMARY KEY AUTO_INCREMENT,                                    NAME VARCHAR(20)                            );                            INSERT INTO stu4 VALUES(NULL ,&quot;ccc&quot;);                                    之后不需要再添加元素，会自动添加                    3.删除自动增长：                            ALTER TABLE stu4 MODIFY id INT;    #外键约束：foreign key：            1.在创建表时，可以添加外键                    *语法：                            create  table 表名(                                ...                                外键列                                constraint 外键名称 foreign key (外键列名称) references 主表名称(主表列名称)                            );                    例子：                                        CREATE TABLE department(                                            id INT PRIMARY KEY AUTO_INCREMENT,                                            dep_name VARCHAR(20),                                            dep_locationion VARCHAR(20)                                        );                                        CREATE TABLE employee(                                            id INT PRIMARY KEY AUTO_INCREMENT,                                            NAME VARCHAR(20),                                            age INT,                                            dep_id INT,                                            CONSTRAINT emp_dep FOREIGN KEY (dep_id) REFERENCES department(id)                                        );                                        INSERT INTO department VALUES(NULL,&#39;研发部&#39;,&#39;广州&#39;),(NULL,&quot;销售部&quot;,&quot;深圳&quot;);                                        INSERT INTO employee (NAME,age,dep_id) VALUE (&quot;张三&quot;,20,1);                                        INSERT INTO employee (NAME,age,dep_id) VALUE (&quot;李四&quot;,21,1);                                        INSERT INTO employee (NAME,age,dep_id) VALUE (&quot;王五&quot;,22,1);                                        INSERT INTO employee (NAME,age,dep_id) VALUE (&quot;大王&quot;,215,2);                                        INSERT INTO employee (NAME,age,dep_id) VALUE (&quot;小王&quot;,24,2);                                        INSERT INTO employee (NAME,age,dep_id) VALUE (&quot;老王&quot;,26,2);                                        SELECT * FROM employee;                                        SELECT * FROM department;            2.删除外键：                    Alter table  表名 drop foreign key 外键名称；                        例子：ALTER TABLE employee DROP FOREIGN KEY emp_dep;            3. 创建表之后，添加外键                    &lt;1&gt;ALTER table 表名 add constraint 外键名称 foreign key (外键字段名称) peferences  主表列名称；            4.级联操作                    1. 添加级联操作                    语法：ALTER TABLE 表名 ADD CONSTRAINT 外键名称                                 FOREIGN KEY (外键字段名称) REFERENCES 主表名称(主表列名称) ON UPDATE CASCADE ON DELETE CASCADE  ;                                例如：ALTER TABLE employee ADD CONSTRAINT  emp_dep FOREIGN KEY                                            (dep_id) REFERENCES department(id) ON UPDATE CASCADE ;                    2. 分类：                                1. 级联更新：ON UPDATE CASCADE                                 2. 级联删除：ON DELETE CASCADE </code></pre><h2 id="数据库的设计："><a href="#数据库的设计：" class="headerlink" title="数据库的设计："></a>数据库的设计：</h2><pre><code>            1.多表之间的关系                1.分类                    &lt;1&gt;一对一：例如：人与身份证                    &lt;2&gt;一对多（多对一）：例如：部门与员工                    &lt;3&gt;多对多：学生与课程的关系                2.实现关系：                    &lt;1&gt;一对多：（多对一）：                            在多的一方建立外键，指向一的一方的主键。                    &lt;2&gt;多对多：                            多对多关系实现是需要借助第三张中间表。至少包含两个字段，                            这两个字段作为第三张表的外键，分别指向两张表的主键                    &lt;3&gt;一对一：                            可以在任意一方添加外键指向另一方的主键                3.演示：                            CREATE TABLE tab_category(                                    cid INT PRIMARY KEY AUTO_INCREMENT,                                    cname VARCHAR(100) NOT NULL UNIQUE                            );                            CREATE TABLE tab_toute(                                            rid INT PRIMARY KEY AUTO_INCREMENT,                                            rname VARCHAR(100) NOT NULL UNIQUE,                                            price DOUBLE,                                            rdate DATE,                                            cid INT,                                            FOREIGN KEY(cid) REFERENCES tab_category(cid)                            );                            CREATE TABLE tab_user(                                        uid INT PRIMARY KEY AUTO_INCREMENT,                                        username VARCHAR(100) UNIQUE NOT NULL,                                        PASSWORD VARCHAR(30) NOT NULL,                                        NAME VARCHAR(100),                                        birthday DATE,                                        sex CHAR(1) DEFAULT &#39;男&#39;,                                        telephone VARCHAR(11),                                        email VARCHAR(100)                            );                            CREATE TABLE tab_favorite(                                        rid INT,                                        DATE DATETIME,                                        uid INT,                                          PRIMARY KEY(rid,uid),                                        FOREIGN KEY (rid) REFERENCES tab_toute(rid),                                        FOREIGN KEY (uid) REFERENCES tab_user(uid)                            );            2.数据库设计的范式                    概念：    设计关系数据库时，遵从不同的规范要求，                                设计出合理的关系型数据库，这些不同的规范要求被称为不同的范式，                                各种范式呈递次规范，越高的范式数据库冗余越小                    类型：第一范式（1NF） 第二范式(2NF) 第三范式(3NF) 巴斯-科德范式（BCNF）                            第四范式（4NF） 和第五范式（5NF 又称为完美范式）                        1. 第一范式（1NF）：每一列都是不可分割的原子数据项                        2. 第二范式（2NF）：在1NF的基础上，非码属性必须完全依赖于码（在1NF基础上消除非主属性对主码的部分函数依赖）                            * 几个概念：                                1. 函数依赖：A--&gt;B,如果通过A属性(属性组)的值，可以确定唯一B属性的值。则称B依赖于A                                    例如：学号--&gt;姓名。  （学号，课程名称） --&gt; 分数                                2. 完全函数依赖：A--&gt;B， 如果A是一个属性组，则B属性值得确定需要依赖于A属性组中所有的属性值。                                    例如：（学号，课程名称） --&gt; 分数                                3. 部分函数依赖：A--&gt;B， 如果A是一个属性组，则B属性值得确定只需要依赖于A属性组中某一些值即可。                                    例如：（学号，课程名称） -- &gt; 姓名                                4. 传递函数依赖：A--&gt;B, B -- &gt;C . 如果通过A属性(属性组)的值，可以确定唯一B属性的值，在通过B属性（属性组）的值可以确定唯一C属性的值，则称 C 传递函数依赖于A                                    例如：学号--&gt;系名，系名--&gt;系主任                                5. 码：如果在一张表中，一个属性或属性组，被其他所有属性所完全依赖，则称这个属性(属性组)为该表的码                                    例如：该表中码为：（学号，课程名称）                                    * 主属性：码属性组中的所有属性                                    * 非主属性：除过码属性组的属性                        3. 第三范式（3NF）：在2NF基础上，任何非主属性不依赖于其它非主属性（在2NF基础上消除传递依赖）</code></pre><h2 id="数据库的备份和还原"><a href="#数据库的备份和还原" class="headerlink" title="数据库的备份和还原"></a>数据库的备份和还原</h2><pre><code>                1. 命令行：                        * 语法：                            * 备份： mysqldump -u用户名 -p密码 数据库名称 &gt; 保存的路径                            * 还原：                                1. 登录数据库                                2. 创建数据库                                3. 使用数据库                                4. 执行文件。source 文件路径                2. 图形化工具：</code></pre><h2 id="多表查询："><a href="#多表查询：" class="headerlink" title="多表查询："></a>多表查询：</h2><pre><code>            * 笛卡尔积：    * 有两个集合A,B .取这两个集合的所有组成情况。    * 要完成多表查询，需要消除无用的数据* 多表查询的分类：    1. 内连接查询：        1. 隐式内连接：使用where条件消除无用数据            * 例子：            -- 查询所有员工信息和对应的部门信息            SELECT * FROM emp,dept WHERE emp.`dept_id` = dept.`id`;            -- 查询员工表的名称，性别。部门表的名称            SELECT emp.name,emp.gender,dept.name FROM em                    便捷写法：                    SELECT                         t1.name, -- 员工表的姓名                        t1.gender,-- 员工表的性别                        t2.name -- 部门表的名称                    FROM                        emp(表名1) t1,                        dept(表名2) t2                    WHERE                         t1.`dept_id` = t2.`id`;    2. 显式内连接：            * 语法： select 字段列表 from 表名1 [inner] join 表名2 on 条件            * 例如：                * SELECT * FROM emp INNER(可省略) JOIN dept ON emp.`dept_id` = dept.`id`;                    * SELECT * FROM emp JOIN dept ON emp.`dept_id` = dept.`id`;        3. 外链接查询：        1. 左外连接：            * 语法：select 字段列表 from 表1 left [outer] join 表2 on 条件；            * 查询的是左表所有数据以及其交集部分。            * 例子：                -- 查询所有员工信息，如果员工有部门，则查询部门名称，没有部门，则不显示部门名称                SELECT     t1.*,t2.`name` FROM emp t1 LEFT JOIN dept t2 ON t1.`dept_id` = t2.`id`;        2. 右外连接：            * 语法：select 字段列表 from 表1 right [outer] join 表2 on 条件；            * 查询的是右表所有数据以及其交集部分。            * 例子：                SELECT * FROM dept t2 RIGHT JOIN emp t1 ON t1.`dept_id` = t2.`id`;*子查询：        * 概念：查询中嵌套查询，称嵌套查询为子查询。            -- 查询工资最高的员工信息            -- 1 查询最高的工资是多少 9000                SELECT MAX(salary) FROM emp;            -- 2 查询员工信息，并且工资等于9000的                SELECT * FROM emp WHERE emp.`salary` = 9000;            -- 一条sql就完成这个操作。子查询                SELECT * FROM emp WHERE emp.`salary` =  (SELECT MAX(salary) FROM emp);            2. 子查询的结果是多行单列的：                * 子查询可以作为条件，使用运算符in来判断                -- 查询&#39;财务部&#39;和&#39;市场部&#39;所有的员工信息                SELECT id FROM dept WHERE NAME = &#39;财务部&#39; OR NAME = &#39;市场部&#39;;                SELECT * FROM emp WHERE dept_id = 3 OR dept_id = 2;                -- 子查询                SELECT * FROM emp WHERE dept_id IN (SELECT id FROM dept WHERE NAME = &#39;财务部&#39; OR NAME = &#39;市场部&#39;);            3. 子查询的结果是多行多列的：                * 子查询可以作为一张虚拟表参与查询                -- 查询员工入职日期是2011-11-11日之后的员工信息和部门信息                -- 子查询                SELECT * FROM dept t1 ,(SELECT * FROM emp WHERE emp.`join_date` &gt; &#39;2011-11-11&#39;) t2                WHERE t1.id = t2.dept_id;                -- 普通内连接                SELECT * FROM emp t1,dept t2 WHERE t1.`dept_id` = t2.`id` AND t1.`join_date` &gt;  &#39;2011-11-11&#39;            * 多表查询练习            -- 部门表            CREATE TABLE dept (              id INT PRIMARY KEY PRIMARY KEY, -- 部门id              dname VARCHAR(50), -- 部门名称              loc VARCHAR(50) -- 部门所在地            );            -- 添加4个部门            INSERT INTO dept(id,dname,loc) VALUES             (10,&#39;教研部&#39;,&#39;北京&#39;),            (20,&#39;学工部&#39;,&#39;上海&#39;),            (30,&#39;销售部&#39;,&#39;广州&#39;),            (40,&#39;财务部&#39;,&#39;深圳&#39;);            -- 职务表，职务名称，职务描述            CREATE TABLE job (              id INT PRIMARY KEY,              jname VARCHAR(20),              description VARCHAR(50)            );            -- 添加4个职务            INSERT INTO job (id, jname, description) VALUES            (1, &#39;董事长&#39;, &#39;管理整个公司，接单&#39;),            (2, &#39;经理&#39;, &#39;管理部门员工&#39;),            (3, &#39;销售员&#39;, &#39;向客人推销产品&#39;),            (4, &#39;文员&#39;, &#39;使用办公软件&#39;);            -- 员工表            CREATE TABLE emp (              id INT PRIMARY KEY, -- 员工id              ename VARCHAR(50), -- 员工姓名              job_id INT, -- 职务id              mgr INT , -- 上级领导              joindate DATE, -- 入职日期              salary DECIMAL(7,2), -- 工资              bonus DECIMAL(7,2), -- 奖金              dept_id INT, -- 所在部门编号              CONSTRAINT emp_jobid_ref_job_id_fk FOREIGN KEY (job_id) REFERENCES job (id),              CONSTRAINT emp_deptid_ref_dept_id_fk FOREIGN KEY (dept_id) REFERENCES dept (id)            );            -- 添加员工            INSERT INTO emp(id,ename,job_id,mgr,joindate,salary,bonus,dept_id) VALUES             (1001,&#39;孙悟空&#39;,4,1004,&#39;2000-12-17&#39;,&#39;8000.00&#39;,NULL,20),            (1002,&#39;卢俊义&#39;,3,1006,&#39;2001-02-20&#39;,&#39;16000.00&#39;,&#39;3000.00&#39;,30),            (1003,&#39;林冲&#39;,3,1006,&#39;2001-02-22&#39;,&#39;12500.00&#39;,&#39;5000.00&#39;,30),            (1004,&#39;唐僧&#39;,2,1009,&#39;2001-04-02&#39;,&#39;29750.00&#39;,NULL,20),            (1005,&#39;李逵&#39;,4,1006,&#39;2001-09-28&#39;,&#39;12500.00&#39;,&#39;14000.00&#39;,30),            (1006,&#39;宋江&#39;,2,1009,&#39;2001-05-01&#39;,&#39;28500.00&#39;,NULL,30),            (1007,&#39;刘备&#39;,2,1009,&#39;2001-09-01&#39;,&#39;24500.00&#39;,NULL,10),            (1008,&#39;猪八戒&#39;,4,1004,&#39;2007-04-19&#39;,&#39;30000.00&#39;,NULL,20),            (1009,&#39;罗贯中&#39;,1,NULL,&#39;2001-11-17&#39;,&#39;50000.00&#39;,NULL,10),            (1010,&#39;吴用&#39;,3,1006,&#39;2001-09-08&#39;,&#39;15000.00&#39;,&#39;0.00&#39;,30),            (1011,&#39;沙僧&#39;,4,1004,&#39;2007-05-23&#39;,&#39;11000.00&#39;,NULL,20),            (1012,&#39;李逵&#39;,4,1006,&#39;2001-12-03&#39;,&#39;9500.00&#39;,NULL,30),            (1013,&#39;小白龙&#39;,4,1004,&#39;2001-12-03&#39;,&#39;30000.00&#39;,NULL,20),            (1014,&#39;关羽&#39;,4,1007,&#39;2002-01-23&#39;,&#39;13000.00&#39;,NULL,10);            -- 工资等级表            CREATE TABLE salarygrade (              grade INT PRIMARY KEY,   -- 级别              losalary INT,  -- 最低工资              hisalary INT -- 最高工资            );            -- 添加5个工资等级            INSERT INTO salarygrade(grade,losalary,hisalary) VALUES             (1,7000,12000),            (2,12010,14000),            (3,14010,20000),            (4,20010,30000),            (5,30010,99990);            -- 需求：            -- 1.查询所有员工信息。查询员工编号，员工姓名，工资，职务名称，职务描述            /*                分析：                    1.员工编号，员工姓名，工资，需要查询emp表  职务名称，职务描述 需要查询job表                    2.查询条件 emp.job_id = job.id            */            SELECT                 t1.`id`, -- 员工编号                t1.`ename`, -- 员工姓名                t1.`salary`,-- 工资                t2.`jname`, -- 职务名称                t2.`description` -- 职务描述            FROM                 emp t1, job t2            WHERE                 t1.`job_id` = t2.`id`;            -- 2.查询员工编号，员工姓名，工资，职务名称，职务描述，部门名称，部门位置            /*                分析：                    1. 员工编号，员工姓名，工资 emp  职务名称，职务描述 job  部门名称，部门位置 dept                    2. 条件： emp.job_id = job.id and emp.dept_id = dept.id            */            SELECT                 t1.`id`, -- 员工编号                t1.`ename`, -- 员工姓名                t1.`salary`,-- 工资                t2.`jname`, -- 职务名称                t2.`description`, -- 职务描述                t3.`dname`, -- 部门名称                t3.`loc` -- 部门位置            FROM                 emp t1, job t2,dept t3            WHERE                 t1.`job_id` = t2.`id` AND t1.`dept_id` = t3.`id`;            -- 3.查询员工姓名，工资，工资等级            /*                分析：                    1.员工姓名，工资 emp  工资等级 salarygrade                    2.条件 emp.salary &gt;= salarygrade.losalary and emp.salary &lt;= salarygrade.hisalary                        emp.salary BETWEEN salarygrade.losalary and salarygrade.hisalary            */            SELECT                 t1.ename ,                t1.`salary`,                t2.*            FROM emp t1, salarygrade t2            WHERE t1.`salary` BETWEEN t2.`losalary` AND t2.`hisalary`;            -- 4.查询员工姓名，工资，职务名称，职务描述，部门名称，部门位置，工资等级            /*                分析：                    1. 员工姓名，工资 emp ， 职务名称，职务描述 job 部门名称，部门位置，dept  工资等级 salarygrade                    2. 条件： emp.job_id = job.id and emp.dept_id = dept.id and emp.salary BETWEEN salarygrade.losalary and salarygrade.hisalary            */            SELECT                 t1.`ename`,                t1.`salary`,                t2.`jname`,                t2.`description`,                t3.`dname`,                t3.`loc`,                t4.`grade`            FROM                 emp t1,job t2,dept t3,salarygrade t4            WHERE                 t1.`job_id` = t2.`id`                 AND t1.`dept_id` = t3.`id`                AND t1.`salary` BETWEEN t4.`losalary` AND t4.`hisalary`;            -- 5.查询出部门编号、部门名称、部门位置、部门人数            /*                分析：                    1.部门编号、部门名称、部门位置 dept 表。 部门人数 emp表                    2.使用分组查询。按照emp.dept_id完成分组，查询count(id)                    3.使用子查询将第2步的查询结果和dept表进行关联查询            */            SELECT                 t1.`id`,t1.`dname`,t1.`loc` , t2.total            FROM                 dept t1,                (SELECT                    dept_id,COUNT(id) total                FROM                     emp                GROUP BY dept_id) t2            WHERE t1.`id` = t2.dept_id;            -- 6.查询所有员工的姓名及其直接上级的姓名,没有领导的员工也需要查询            /*                分析：                    1.姓名 emp， 直接上级的姓名 emp                        * emp表的id 和 mgr 是自关联                    2.条件 emp.id = emp.mgr                    3.查询左表的所有数据，和 交集数据                        * 使用左外连接查询            */            /*            select                t1.ename,                t1.mgr,                t2.`id`,                t2.ename            from emp t1, emp t2            where t1.mgr = t2.`id`;            */            SELECT                 t1.ename,                t1.mgr,                t2.`id`,                t2.`ename`            FROM emp t1            LEFT JOIN emp t2            ON t1.`mgr` = t2.`id`;</code></pre><h2 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h2><pre><code>1. 事务的基本介绍    1. 概念：        *  如果一个包含多个步骤的业务操作，被事务管理，那么这些操作要么同时成功，要么同时失败。    2. 操作：        1. 开启事务： start transaction;        2. 回滚：rollback;        3. 提交：commit;    3. 例子：        CREATE TABLE account (            id INT PRIMARY KEY AUTO_INCREMENT,            NAME VARCHAR(10),            balance DOUBLE        );        -- 添加数据        INSERT INTO account (NAME, balance) VALUES (&#39;zhangsan&#39;, 1000), (&#39;lisi&#39;, 1000);        SELECT * FROM account;        UPDATE account SET balance = 1000;        -- 张三给李四转账 500 元        -- 0. 开启事务        START TRANSACTION;        -- 1. 张三账户 -500        UPDATE account SET balance = balance - 500 WHERE NAME = &#39;zhangsan&#39;;        -- 2. 李四账户 +500        -- 出错了...        UPDATE account SET balance = balance + 500 WHERE NAME = &#39;lisi&#39;;        -- 发现执行没有问题，提交事务        COMMIT;        -- 发现出问题了，回滚事务        ROLLBACK;    4. MySQL数据库中事务默认自动提交        * 事务提交的两种方式：            * 自动提交：                * mysql就是自动提交的                * 一条DML(增删改)语句会自动提交一次事务。            * 手动提交：                * Oracle 数据库默认是手动提交事务                * 需要先开启事务，再提交        * 修改事务的默认提交方式：            * 查看事务的默认提交方式：SELECT @@autocommit; -- 1 代表自动提交  0 代表手动提交            * 修改默认提交方式： set @@autocommit = 0;2. 事务的四大特征：    1. 原子性：是不可分割的最小操作单位，要么同时成功，要么同时失败。    2. 持久性：当事务提交或回滚后，数据库会持久化的保存数据。    3. 隔离性：多个事务之间。相互独立。    4. 一致性：事务操作前后，数据总量不变3. 事务的隔离级别（了解）    * 概念：多个事务之间隔离的，相互独立的。但是如果多个事务操作同一批数据，则会引发一些问题，设置不同的隔离级别就可以解决这些问题。    * 存在问题：        1. 脏读：一个事务，读取到另一个事务中没有提交的数据        2. 不可重复读(虚读)：在同一个事务中，两次读取到的数据不一样。        3. 幻读：一个事务操作(DML)数据表中所有记录，另一个事务添加了一条数据，则第一个事务查询不到自己的修改。    * 隔离级别：        1. read uncommitted：读未提交            * 产生的问题：脏读、不可重复读、幻读        2. read committed：读已提交 （Oracle）            * 产生的问题：不可重复读、幻读        3. repeatable read：可重复读 （MySQL默认）            * 产生的问题：幻读        4. serializable：串行化            * 可以解决所有的问题        * 注意：隔离级别从小到大安全性越来越高，但是效率越来越低        * 数据库查询隔离级别：            * select @@tx_isolation;        * 数据库设置隔离级别：            * set global transaction isolation level  级别字符串;    * 演示：        set global transaction isolation level read uncommitted;        start transaction;        -- 转账操作        update account set balance = balance - 500 where id = 1;        update account set balance = balance + 500 where id = 2;</code></pre><h2 id="DCL："><a href="#DCL：" class="headerlink" title="DCL："></a>DCL：</h2><pre><code>* SQL分类：    1. DDL：操作数据库和表    2. DML：增删改表中数据    3. DQL：查询表中数据    4. DCL：管理用户，授权* DBA：数据库管理员* DCL：管理用户，授权    1. 管理用户        1. 添加用户：            * 语法：CREATE USER &#39;用户名&#39;@&#39;主机名&#39; IDENTIFIED BY &#39;密码&#39;;        2. 删除用户：            * 语法：DROP USER &#39;用户名&#39;@&#39;主机名&#39;;        3. 修改用户密码：            UPDATE USER SET PASSWORD = PASSWORD(&#39;新密码&#39;) WHERE USER = &#39;用户名&#39;;            UPDATE USER SET PASSWORD = PASSWORD(&#39;abc&#39;) WHERE USER = &#39;lisi&#39;;            SET PASSWORD FOR &#39;用户名&#39;@&#39;主机名&#39; = PASSWORD(&#39;新密码&#39;);            SET PASSWORD FOR &#39;root&#39;@&#39;localhost&#39; = PASSWORD(&#39;123&#39;);            * mysql中忘记了root用户的密码？                1. cmd -- &gt; net stop mysql 停止mysql服务                    * 需要管理员运行该cmd                2. 使用无验证方式启动mysql服务： mysqld --skip-grant-tables                3. 打开新的cmd窗口,直接输入mysql命令，敲回车。就可以登录成功                4. use mysql;                5. update user set password = password(&#39;你的新密码&#39;) where user = &#39;root&#39;;                6. 关闭两个窗口                7. 打开任务管理器，手动结束mysqld.exe 的进程                8. 启动mysql服务                9. 使用新密码登录。        4. 查询用户：            -- 1. 切换到mysql数据库            USE myql;            -- 2. 查询user表            SELECT * FROM USER;            * 通配符： % 表示可以在任意主机使用用户登录数据库    2. 权限管理：        1. 查询权限：            -- 查询权限            SHOW GRANTS FOR &#39;用户名&#39;@&#39;主机名&#39;;            SHOW GRANTS FOR &#39;lisi&#39;@&#39;%&#39;;        2. 授予权限：            -- 授予权限            grant 权限列表 on 数据库名.表名 to &#39;用户名&#39;@&#39;主机名&#39;;            -- 给张三用户授予所有权限，在任意数据库任意表上            GRANT ALL ON *.* TO &#39;zhangsan&#39;@&#39;localhost&#39;;        3. 撤销权限：            -- 撤销权限：            revoke 权限列表 on 数据库名.表名 from &#39;用户名&#39;@&#39;主机名&#39;;            REVOKE UPDATE ON db3.`account` FROM &#39;lisi&#39;@&#39;%&#39;;</code></pre>]]></content>
      
      
      <categories>
          
          <category> mysql数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 原创 </tag>
            
            <tag> 数据库 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
